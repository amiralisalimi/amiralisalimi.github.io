# Weather App

<div dir="rtl">

<h1>پاسخ سوالات</h1>
<h2>سوال ۱)</h2>

<p>پوشه .git یکی از مهم‌ترین اجزای هر مخزن یا repository گیت است. یان پوشه اطلاعات داخلی مربوط به کنترل نسخه ها را ذخیره می‌کند و گیت از آن برای ردیابی تغییرات، مدیریت تاریخچه، شاخه ها و ... استفاده میکند.</p>
<p>پوشه .git یک پوشه پنهان است که در ریشه‌ی یک پروژه گیت قرار می‌گیرد و شامل تمام اطلاعات مورد نیاز برای مدیریت نسخه‌ها توسط Git است. بدون این پوشه، پروژه‌ی شما دیگر یک مخزن گیت محسوب نمی‌شود.</p>

<p>اطلاعاتی که در این پوشه ذخیره میشود عبارت اند از:</p>
<table>
    <tr>
        <td>نام</td>
        <td>توضیح</td>
    </tr>
    <tr>
        <td>HEAD</td>
        <td>شاخه‌ی فعلی فعال را مشخص می‌کند</td>
    </tr>
    <tr>
        <td>config</td>
        <td>تنظیمات مربوط به مخزن مانند آدرس ریموت یا تنظیمات کاربر</td>
    </tr>
    <tr>
        <td>/objects</td>
        <td>تمام snapshotها (نسخه‌ها) به صورت فشرده در این پوشه ذخیره می‌شوند</td>
    </tr>
    <tr>
        <td>/refs</td>
        <td>شامل اشاره‌گرها به commitها، مانند شاخه‌ها (branches) و برچسب‌ها (tags</td>
    </tr>
    <tr>
        <td>/logs</td>
        <td>تاریخچه تغییرات روی شاخه‌ها و HEAD</td>
    </tr>
    <tr>
        <td>index</td>
        <td>staging area که تغییرات آماده‌ی commit شدن را نگه می‌دارد</td>
    </tr>
    <tr>
        <td>/hooks</td>
        <td>اسکریپت‌هایی برای اجرای عملیات خاص قبل یا بعد از رخدادهای مختلف مثل commit</td>
    </tr>
</table>

<p>این پوشه با دستور git init در هنگام ایجاد مخزن پروژه ایجاد می‌شود</p>


<h2>سوال ۲)</h2>
<p>در دنیای توسعه نرم‌افزار، واژه‌ی atomic (اتمی) به این معناست که یک عملیات باید کامل و یک‌جا انجام شود؛ یا کاملاً انجام شود یا اصلاً انجام نشود، و نیمه‌کاره باقی نماند.</p>

<p>منظور از atomic commit این است که یک کامیت تنها یک هدف را دنبال کند و فقط یمک تغییر منطقی در کد ایجاد کند.</p>
<p>ویژگی های atomic commit:</p>
<ul>
    <li>فقط یک مسئله/ویژگی/باگ را تغییر می‌دهد</li>
    <li>قابل بازگشت (revert) است بدون تأثیر جانبی روی سایر بخش‌ها</li>
    <li>واضح و قابل درک است</li>
    <li>باعث ساده‌تر شدن بررسی (code review) می‌شود</li>
</ul>

<p>منطور از atomic pull request یک PR است که فقط یک هدف یا ویژگی یا تغییر مستقل را پیاده‌سازی می‌کند.</p>

<ul>
    <li>فقط شامل یک تغییر منطقی است (مثلاً اضافه کردن یک API خاص)</li>
    <li>بررسی و تست آن آسان است</li>
    <li>وابستگی به سایر PRها ندارد</li>
    <li>می‌توان آن را بدون اثر جانبی merge یا revert کرد</li>
</ul>

<h2>سوال ۳)</h2>

<h3>git fetch:</h3>
<p>فقط تغییرات جدید (commitها) را از مخزن remote دریافت می‌کند بدون اعمال آنها روی کد محلی.</p>

<h3>git pull:</h3>
<p>ترکیبی از fetch و merge است: یعنی هم تغییرات remote را می‌گیرد و هم آنها را با شاخه فعلی ادغام می‌کند.</p>

<h3>git merge:</h3>
<p>دو شاخه را با هم ادغام می‌کند و یک commit ادغام (merge commit) ایجاد می‌کند (اگر نیاز باشد).</p>

<h3>git rebase:</h3>
<p>تغییرات شاخه فعلی را روی یک شاخه‌ی دیگر بازنویسی می‌کند به گونه‌ای که تاریخچه‌ی commitها تمیزتر شود.</p>

<h3>git cherry-pick:</h3>
<p>فقط یک commit خاص را از یک شاخه دیگر برداشته و به شاخه فعلی اضافه می‌کند.</p>

<h3>مقایسه:</h3>

| دستور             | تغییر روی کد محلی؟ | ادغام commit؟  | بازنویسی تاریخچه؟    | استفاده متداول       |
| ----------------- | ------------------ | -------------- | -------------------- | -------------------- |
| `git fetch`       | ❌                  | ❌              | ❌                    | دیدن تغییرات remote  |
| `git pull`        | ✅ (fetch + merge)  | ✅              | ❌ (یا با `--rebase`) | به‌روز کردن پروژه    |
| `git merge`       | ✅                  | ✅              | ❌                    | ادغام کامل شاخه‌ها   |
| `git rebase`      | ✅                  | ✅ (اما linear) | ✅                    | تمیز کردن تاریخچه    |
| `git cherry-pick` | ✅                  | فقط یک commit  | ❌                    | انتقال یک commit خاص |


<h2>سوال ۴)</h2>

<h3>git reset:</h3>
<p>تغییر موقعیت HEAD (یعنی آخرین commit فعال) به commit قبلی. می‌تواند تغییرات staged و حتی فایل‌ها را هم تغییر بدهد، بسته به حالت استفاده.</p>

<h3>git revert:</h3>
<p>برعکس کردن اثر یک commit خاص با ایجاد یک commit جدید.</p>

<h3>git restore:</h3>
<p>برای بازگرداندن فایل‌ها به وضعیت قبلی (یا از staging area یا از آخرین commit).</p>

<h3>git switch:</h3>
<p>برای تعویض بین شاخه‌ها (branches)، راهی ساده‌تر و مدرن‌تر از checkout.</p>

<h3>git checkout:</h3>
<p>دستور قدیمی‌تر و همه‌کاره‌تر برای جابجایی بین شاخه‌ها یا بازیابی فایل‌ها.</p>

<h3>مقایسه:</h3>

| دستور      | عملکرد اصلی                      | تأثیر روی فایل‌ها | تغییر تاریخچه؟  | قابل بازگشت؟    | مناسب برای           |
| ---------- | -------------------------------- | ----------------- | --------------- | --------------- | -------------------- |
| `reset`    | بردن HEAD به عقب                 | بسته به حالت      | ✅ (در `--hard`) | ❌ (در `--hard`) | حذف commit محلی      |
| `revert`   | معکوس کردن یک commit             | ✅                 | ❌               | ✅               | پروژه‌های مشترک      |
| `restore`  | بازگردانی فایل‌ها به commit قبلی | ✅                 | ❌               | ✅               | مدیریت فایل‌ها       |
| `switch`   | جابجایی بین شاخه‌ها              | ❌                 | ❌               | ✅               | شاخه‌ها (مدرن)       |
| `checkout` | جابجایی شاخه/بازیابی فایل        | ✅                 | ❌               | ✅               | فایل یا شاخه (قدیمی) |

<h2>سوال ۵)</h2>
<p>Stage (یا Index) یک ناحیه موقت در Git هست که تغییراتی که قصد داریم commit کنیم در آن قرار می‌گیرند. یعنی وقتی فایلی را تغییر می‌دهی، آن تغییر فوراً وارد commit نمی‌شود — بلکه اول باید آن را "stage" کنی.</p>
<p>git stash تغییرات جاری در پروژه را به طور موقت کنار می‌گذارد (stash می‌کند) و پروژه را به حالت تمیز (clean working directory) برمی‌گرداند — انگار هیچ تغییری ندادی.</p>

<h3>دستورات مربوط به stash:</h3>

| دستور             | توضیح                                               |
| ----------------- | --------------------------------------------------- |
| `git stash`       | ذخیره تغییرات در stash و پاک کردن آنها از شاخه فعلی |
| `git stash list`  | نمایش لیست stashهای ذخیره‌شده                       |
| `git stash pop`   | اعمال آخرین stash و حذف آن از لیست                  |
| `git stash apply` | اعمال آخرین stash (بدون حذف آن)                     |
| `git stash drop`  | حذف stash خاص                                       |
| `git stash clear` | حذف تمام stashها                                    |


<h2>سوال ۶)</h2>
<h3>snapshot در git:</h3>
<p>در Git، یک snapshot به معنی "تصویر کامل از وضعیت فایل‌های پروژه در یک لحظه مشخص" است. این snapshot نشان می‌دهد که در آن لحظه، چه فایل‌هایی وجود داشته‌اند، محتویاتشان چه بوده و چه ساختاری داشته‌اند.</p>

<h3>تفاوت Git با سایر سیستم‌های کنترل نسخه:</h3>
<p>سیستم‌هایی مثل Subversion (SVN) یا CVS تغییرات را به شکل diff (فقط تفاوت‌ها) ذخیره می‌کنند. اما Git هر بار که commit می‌کنیم، یک snapshot از کل پروژه می‌سازد. </p>

<h3>ارتباط snapshot با commit:</h3>
<p>یک commit در Git = یک snapshot + متادیتا (اطلاعات اضافی)</p>

<p>اطلاعات اضافی (متادیتا) شامل:</p>
<ul>
    <li>پیام commit</li>
    <li>نویسنده commit</li>
    <li>زمان commit</li>
    <li>اشاره‌گر به commit والد (یا والدها)</li>
</ul>

<h2>سوال ۷)</h2>

<h3>Local Repository (مخزن محلی)</h3>
<p>مخزنی است که روی سیستم شخصی فرد قرار دارد. شامل:</p>
<ul>
    <li>فایل‌های کاری (working directory)</li>
    <li>staging area (index)</li>
    <li>تاریخچه commitها (در .git/)</li>
</ul>

<h3> Remote Repository (مخزن راه‌دور)</h3>
<p>مخزنی است که روی یک سرور یا سرویس‌ ابری مانند GitHub، GitLab، Bitbucket و ... قرار دارد.
هدف آن اشتراک‌گذاری کد با دیگران و هماهنگی تیمی است.</p>

</div>

