# Weather App

<div dir="rtl">

<h1>آدرس مخزن</h1>
<b>https://github.com/amiralisalimi/amiralisalimi.github.io</b>

<h1>توضیحات پروژه</h1>

<h2>توضیحات برنچ ها</h2>
<p>در این پروژه از یسه برنج اصلی استفاده شده است. برنچ های main, feature و dev. برنچ main برنچ اصلی برنامه است و خروجی برنامه از این برنچ به وجود می‌آید. توسعه اعضای گروه پس از استیبل شدن روی این برنچ مرج می‌شود.
برنچ dev هم برنچی است که توسعه برنامه روی آن انجام می‌شود و هنگامی که استیبل شد این برنچ روی main مرج می‌شود. برنچ feature هم برای افزودن ویژگی جدید به برنامه همزمان با برنچ main است و ویژگی جدیدی را به کد های main اضافه می‌کند.</p>

<h2>توضیحات کامیت ها</h2>
<p>برای توضیح کامیت ها از اولین کامیت تا انتها توضیح مختصری درباره هر کامیت خواهیم داد.</p>

<p>در ابتدا برای آغاز پروژه مخزن را ایجاد کردیم و مخزن لوکال را به ریموت متصل کردیم.</p>
<p>برای این که بعضی از فایل ها توسط گیت رصد و کامیت نشوند یک فایل .gitignore ایجاد کردیم.</p>
<p>برای آغاز پروژه کد های اولیه html و دکمه نشان دادن نتیجه را در برنامه قرار دادیم.</p>
<p>یک استایل ساده برای کد های html قرار داده شده توسط کد های css ایجاد کردیم.</p>
<p>تابع js ساده ای در کد قرار دادیم تا وقتی که کاربر روی دکمه کلیک کرد پیامی به او نشان دهد.</p>
<p>در ادامه توسط این کامیت ویژگی ای اضافه شد که کاربر با زدن یک کلیک موقعیت خود را مشخص می‌کند.</p>
<p>یک داده هواشناسی مصنوعی برای پیش‌بینی ایجاد کردیم.</p>
<p>توضیحات و استایل برای دکمه گرفتن داده های آب و هوا ایجاد کردیم.</p>
<p>در این کامیت API سایت OpenWeatherMap را به برنامه اضافه کردیم.</p>
<p>از این کامیت به بعد برنامه به شکل پویا اطلاعات را می‌گیرد در نتیجه داده های مصنوعی را پاک کردیم و برنامه از حالیت static در آمد.</p>
<p>bootstrap را به وسیله loader به برنامه اضافه کردیم.</p>
<p>تاریخ و زمان اضافه شد.</p>
<p>براساس آب و هوا رنگ اضافه شد.</p>
<p>به عنوان یک پیغام پشتیبان به برنامه داده فیک آب و هوا اضافه کردیم.</p>
<p>از این کامیت ویژگی وارد کردن دستی شهر به برنامه اضافه شد.</p>
<p>جواب سوال های ۱ و ۲ در فایل readme درج شد.</p>
<p>جواب پرسش ۳ در فایل readme درج شد.</p>
<p>جدول مقایسه برای سوال ۳ در فایل readme درج شد.</p>
<p>جواب سوال ۴ در فایل readme درج شد.</p>
<p>جواب سوال ۵ در فایل readme درج شد.</p>
<p>جواب سوال ۶ و ۷ در فایل readme درج شد.</p>
<p>فایل readme ریفکتور شد.</p>
<p>فایل deploy.yml را ایجاد کردیم.</p>
<p>فایل readme را ریفکتور کردیم و توضیحات پروژه را به آن اضافه کردیم.</p>


<h1>پاسخ سوالات</h1>
<h2>سوال ۱)</h2>

<p>پوشه .git یکی از مهم‌ترین اجزای هر مخزن یا repository گیت است. این پوشه اطلاعات داخلی مربوط به کنترل نسخه ها را ذخیره می‌کند و گیت از آن برای ردیابی تغییرات، مدیریت تاریخچه، شاخه ها و ... استفاده میکند.</p>
<p>پوشه .git یک پوشه پنهان است که در ریشه‌ی یک پروژه گیت قرار می‌گیرد و شامل تمام اطلاعات مورد نیاز برای مدیریت نسخه‌ها توسط Git است. بدون این پوشه، پروژه‌ی شما دیگر یک مخزن گیت محسوب نمی‌شود.</p>

<p>اطلاعاتی که در این پوشه ذخیره میشود عبارت اند از:</p>
<table>
    <tr>
        <td>نام</td>
        <td>توضیح</td>
    </tr>
    <tr>
        <td>HEAD</td>
        <td>شاخه‌ی فعلی فعال را مشخص می‌کند</td>
    </tr>
    <tr>
        <td>config</td>
        <td>تنظیمات مربوط به مخزن مانند آدرس ریموت یا تنظیمات کاربر</td>
    </tr>
    <tr>
        <td>/objects</td>
        <td>تمام snapshotها (نسخه‌ها) به صورت فشرده در این پوشه ذخیره می‌شوند</td>
    </tr>
    <tr>
        <td>/refs</td>
        <td>شامل اشاره‌گرها به commitها، مانند شاخه‌ها (branches) و برچسب‌ها (tags</td>
    </tr>
    <tr>
        <td>/logs</td>
        <td>تاریخچه تغییرات روی شاخه‌ها و HEAD</td>
    </tr>
    <tr>
        <td>index</td>
        <td>staging area که تغییرات آماده‌ی commit شدن را نگه می‌دارد</td>
    </tr>
    <tr>
        <td>/hooks</td>
        <td>اسکریپت‌هایی برای اجرای عملیات خاص قبل یا بعد از رخدادهای مختلف مثل commit</td>
    </tr>
</table>

<p>این پوشه با دستور git init در هنگام ایجاد مخزن پروژه ایجاد می‌شود</p>


<h2>سوال ۲)</h2>
<p>در دنیای توسعه نرم‌افزار، واژه‌ی atomic (اتمی) به این معناست که یک عملیات باید کامل و یک‌جا انجام شود؛ یا کاملاً انجام شود یا اصلاً انجام نشود، و نیمه‌کاره باقی نماند.</p>

<p>منظور از atomic commit این است که یک کامیت تنها یک هدف را دنبال کند و فقط یک تغییر منطقی در کد ایجاد کند.</p>
<p>ویژگی های atomic commit:</p>
<ul>
    <li>فقط یک مسئله/ویژگی/باگ را تغییر می‌دهد</li>
    <li>قابل بازگشت (revert) است بدون تأثیر جانبی روی سایر بخش‌ها</li>
    <li>واضح و قابل درک است</li>
    <li>باعث ساده‌تر شدن بررسی (code review) می‌شود</li>
</ul>

<p>منطور از atomic pull request یک PR است که فقط یک هدف یا ویژگی یا تغییر مستقل را پیاده‌سازی می‌کند.</p>

<ul>
    <li>فقط شامل یک تغییر منطقی است (مثلاً اضافه کردن یک API خاص)</li>
    <li>بررسی و تست آن آسان است</li>
    <li>وابستگی به سایر PRها ندارد</li>
    <li>می‌توان آن را بدون اثر جانبی merge یا revert کرد</li>
</ul>

<h2>سوال ۳)</h2>

<h3>git fetch:</h3>
<p>فقط تغییرات جدید (commitها) را از مخزن remote دریافت می‌کند بدون اعمال آنها روی کد محلی.</p>

<h3>git pull:</h3>
<p>ترکیبی از fetch و merge است: یعنی هم تغییرات remote را می‌گیرد و هم آنها را با شاخه فعلی ادغام می‌کند.</p>

<h3>git merge:</h3>
<p>دو شاخه را با هم ادغام می‌کند و یک commit ادغام (merge commit) ایجاد می‌کند (اگر نیاز باشد).</p>

<h3>git rebase:</h3>
<p>تغییرات شاخه فعلی را روی یک شاخه‌ی دیگر بازنویسی می‌کند به گونه‌ای که تاریخچه‌ی commitها تمیزتر شود.</p>

<h3>git cherry-pick:</h3>
<p>فقط یک commit خاص را از یک شاخه دیگر برداشته و به شاخه فعلی اضافه می‌کند.</p>

<h3>مقایسه:</h3>

| دستور             | تغییر روی کد محلی؟ | ادغام commit؟  | بازنویسی تاریخچه؟    | استفاده متداول       |
| ----------------- | ------------------ | -------------- | -------------------- | -------------------- |
| `git fetch`       | ❌                  | ❌              | ❌                    | دیدن تغییرات remote  |
| `git pull`        | ✅ (fetch + merge)  | ✅              | ❌ (یا با `--rebase`) | به‌روز کردن پروژه    |
| `git merge`       | ✅                  | ✅              | ❌                    | ادغام کامل شاخه‌ها   |
| `git rebase`      | ✅                  | ✅ (اما linear) | ✅                    | تمیز کردن تاریخچه    |
| `git cherry-pick` | ✅                  | فقط یک commit  | ❌                    | انتقال یک commit خاص |


<h2>سوال ۴)</h2>

<h3>git reset:</h3>
<p>تغییر موقعیت HEAD (یعنی آخرین commit فعال) به commit قبلی. می‌تواند تغییرات staged و حتی فایل‌ها را هم تغییر بدهد، بسته به حالت استفاده.</p>

<h3>git revert:</h3>
<p>برعکس کردن اثر یک commit خاص با ایجاد یک commit جدید.</p>

<h3>git restore:</h3>
<p>برای بازگرداندن فایل‌ها به وضعیت قبلی (یا از staging area یا از آخرین commit).</p>

<h3>git switch:</h3>
<p>برای تعویض بین شاخه‌ها (branches)، راهی ساده‌تر و مدرن‌تر از checkout.</p>

<h3>git checkout:</h3>
<p>دستور قدیمی‌تر و همه‌کاره‌تر برای جابجایی بین شاخه‌ها یا بازیابی فایل‌ها.</p>

<h3>مقایسه:</h3>

| دستور      | عملکرد اصلی                      | تأثیر روی فایل‌ها | تغییر تاریخچه؟  | قابل بازگشت؟    | مناسب برای           |
| ---------- | -------------------------------- | ----------------- | --------------- | --------------- | -------------------- |
| `reset`    | بردن HEAD به عقب                 | بسته به حالت      | ✅ (در `--hard`) | ❌ (در `--hard`) | حذف commit محلی      |
| `revert`   | معکوس کردن یک commit             | ✅                 | ❌               | ✅               | پروژه‌های مشترک      |
| `restore`  | بازگردانی فایل‌ها به commit قبلی | ✅                 | ❌               | ✅               | مدیریت فایل‌ها       |
| `switch`   | جابجایی بین شاخه‌ها              | ❌                 | ❌               | ✅               | شاخه‌ها (مدرن)       |
| `checkout` | جابجایی شاخه/بازیابی فایل        | ✅                 | ❌               | ✅               | فایل یا شاخه (قدیمی) |

<h2>سوال ۵)</h2>
<p>Stage (یا Index) یک ناحیه موقت در Git هست که تغییراتی که قصد داریم commit کنیم در آن قرار می‌گیرند. یعنی وقتی فایلی را تغییر می‌دهیم، آن تغییر فوراً وارد commit نمی‌شود — بلکه اول باید آن را "stage" کنیم.</p>
<p>git stash تغییرات جاری در پروژه را به طور موقت کنار می‌گذارد (stash می‌کند) و پروژه را به حالت تمیز (clean working directory) برمی‌گرداند.</p>

<h3>دستورات مربوط به stash:</h3>

| دستور             | توضیح                                               |
| ----------------- | --------------------------------------------------- |
| `git stash`       | ذخیره تغییرات در stash و پاک کردن آنها از شاخه فعلی |
| `git stash list`  | نمایش لیست stashهای ذخیره‌شده                       |
| `git stash pop`   | اعمال آخرین stash و حذف آن از لیست                  |
| `git stash apply` | اعمال آخرین stash (بدون حذف آن)                     |
| `git stash drop`  | حذف stash خاص                                       |
| `git stash clear` | حذف تمام stashها                                    |


<h2>سوال ۶)</h2>
<h3>snapshot در git:</h3>
<p>در Git، یک snapshot به معنی "تصویر کامل از وضعیت فایل‌های پروژه در یک لحظه مشخص" است. این snapshot نشان می‌دهد که در آن لحظه، چه فایل‌هایی وجود داشته‌اند، محتویاتشان چه بوده و چه ساختاری داشته‌اند.</p>

<h3>تفاوت Git با سایر سیستم‌های کنترل نسخه:</h3>
<p>سیستم‌هایی مثل Subversion (SVN) یا CVS تغییرات را به شکل diff (فقط تفاوت‌ها) ذخیره می‌کنند. اما Git هر بار که commit می‌کنیم، یک snapshot از کل پروژه می‌سازد. </p>

<h3>ارتباط snapshot با commit:</h3>
<p>یک commit در Git = یک snapshot + متادیتا (اطلاعات اضافی)</p>

<p>اطلاعات اضافی (متادیتا) شامل:</p>
<ul>
    <li>پیام commit</li>
    <li>نویسنده commit</li>
    <li>زمان commit</li>
    <li>اشاره‌گر به commit والد (یا والدها)</li>
</ul>

<h2>سوال ۷)</h2>

<h3>Local Repository (مخزن محلی)</h3>
<p>مخزنی است که روی سیستم شخصی فرد قرار دارد. شامل:</p>
<ul>
    <li>فایل‌های کاری (working directory)</li>
    <li>staging area (index)</li>
    <li>تاریخچه commitها (در .git/)</li>
</ul>

<h3> Remote Repository (مخزن راه‌دور)</h3>
<p>مخزنی است که روی یک سرور یا سرویس‌ ابری مانند GitHub، GitLab، Bitbucket و ... قرار دارد.
هدف آن اشتراک‌گذاری کد با دیگران و هماهنگی تیمی است.</p>

</div>

